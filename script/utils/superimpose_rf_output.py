"""
3/17/2025
Lisa P. 
tested on TACC ls6 biotite env


Script to 
Make json file for mask of fixed position 
to be used as input to ProteinMPNN

What script would do
1. Take in input, 2 PDBS and one text file
    one is reference file of starting PDB structure
    one is output from RFDiffusion, made with the starting PDB 
    one text file for a .jsonl of residue to keep fixed in the starting PDB

2. Read in all files and perform alignment

3. Match the residue numbers from the reference file to the output file 
based on C-a atom proximity

#Sample format for jsonl looks like this
#aaron's inital residue choice
{"5B1B": {"A": [240, 244, 290, 291, 316, 354, 368, 376, 438, 439]}}

"""
import biotite
from biotite.structure.io.pdb import PDBFile
from biotite.structure import AtomArray, Atom, distance
import numpy as np
import os

#original PDB
REF_PDB = r"/work/09069/dhp563/ls6/HCO_modelling/step1_runRFDiffusion/attempt8_5B1B_helix_motifscaffolding_larger_sel/input/5B1B_chainA_heme_copper.pdb"
TEST_RFDIFF_OUT = r"/work/09069/dhp563/ls6/HCO_modelling/step1_runRFDiffusion/attempt8_5B1B_helix_motifscaffolding_larger_sel/output/all_atom_helix_scaffolding_1.pdb"

#directory of input pdb generated by RFDiffusion
INPUT_DIR = r"/work/09069/dhp563/ls6/HCO_modelling/step1_runRFDiffusion/attempt8_5B1B_helix_motifscaffolding_larger_sel/output"

#directory for output jsonl
OUT_DIR = r"/work/09069/dhp563/ls6/HCO_modelling/step1_runRFDiffusion/attempt8_5B1B_helix_motifscaffolding_larger_sel/residue_indexing_mapping"

#residue indices of reference structure to keep intact
#skipping 428 and 439 due to being outside of the desired helix
TEMPLATE_RESIDUE_LIST = [240, 244, 290, 291, 316, 354, 368, 376]


##############################
# FUNCTIONS
##############################

def find_nearest_ca(ref_pdb, rfdiffusion_pdb, residue_number) -> tuple:
    """
    Find the nearest C-alpha atom in the RFDiffusion output
    to the residue in the reference PDB
    """
    #specific residue C-alpha atom in reference PDB
    ref_residue_ca = ref_pdb[(ref_pdb.res_id == residue_number) & (ref_pdb.atom_name == "CA")][0]
    
    #all rf_diffusion C-alpha atoms
    rf_diffusion_ca = rfdiffusion_pdb[rfdiffusion_pdb.atom_name == "CA"]

    #find nearest C-alpha atom in RFDiffusion output to the residue in the reference PDB
    distances = [distance(map_ca, ref_residue_ca) for map_ca in rf_diffusion_ca]

    #create a mapping of residue number to distance
    residue_distance_map = {(atom.res_id, atom.res_name): distance for atom, distance in zip(rf_diffusion_ca, distances)}

    #sort the dictionary by distance
    sorted_residue_distance = dict(sorted(residue_distance_map.items(), key=lambda item: item[1]))

    #return the residue number of the nearest C-alpha atom
    nearest_res_id, nearest_res_name = list(sorted_residue_distance.keys())[0]
    
    return nearest_res_id, nearest_res_name
    
    
def residue_numeric_mapping(ref_pdb: AtomArray, rfdiffusion_pdb: AtomArray, residue_list: list) -> dict:
    """
    Take a reference PDB and RFDiffusion output
    map residue numbering from reference PDB to RFDiffusion output
    based on C-alpha atom proximity
    return a dictionary of residue number: {nearest residue number: nearest c-alpha RFDiffusion output}
    """
    residue_map = {}
    for residue in residue_list:
        nearest_id, nearest_name = find_nearest_ca(ref_pdb, rfdiffusion_pdb, residue)
        residue_map[residue] = {'nearest_id': nearest_id, 'nearest_name': nearest_name}
    
    print(residue_map)  
    return residue_map

def write_jsonl_string(residue_map: dict, structure_name: str, chain: str, out_file: str) -> str:
    """
    Write a dictionary of the format
    {"5B1B": {"A": [240, 244, 290, 291, 316, 354, 368, 376, 438, 439]}}
    
    mapping a structure to a chain to a list of residue numbers

    residue_map: dictionary of residue number: {nearest residue number: nearest c-alpha RFDiffusion output}
    structure_name: name of the structure
    chain: chain in the structure

    """
    id_list = [int(residue['nearest_id']) for residue in residue_map.values()]
    out_string = f'{{"{structure_name}": {{"{chain}": {id_list}}}}}\n'
    with open(out_file, "w") as f:
        f.write(out_string)


def superimpose_structure(ref_pdb: AtomArray, rfdiffusion_pdb: AtomArray): 
    """
    Take two PDBFiles and superimpose then
    """
    oriented_rfdiff_struct, _, _, _ = biotite.structure.superimpose_homologs(ref_pdb, rfdiffusion_pdb)
    return oriented_rfdiff_struct

def write_pdb(out_pdb: AtomArray, out_file: str):

    outfile = PDBFile()
    outfile.set_structure(out_pdb) 
    outfile.write(out_file)

def test():
    ref_pdb = PDBFile.read(REF_PDB).get_structure()[0]
    test_pdb = PDBFile.read(TEST_RFDIFF_OUT).get_structure()[0]
    transformed = superimpose_structure(ref_pdb, test_pdb)
    
    #structure name of RFDiffusion output
    test_struct_name = os.path.basename(TEST_RFDIFF_OUT).split(".")[0]

    #fullpath outfile jsonl
    out_file = os.path.join(OUT_DIR, f"{test_struct_name}_fixed.jsonl")

    #get residue mapping
    
    residue_map = residue_numeric_mapping(ref_pdb, transformed, TEMPLATE_RESIDUE_LIST)
    write_jsonl_string(residue_map, test_struct_name, "A", out_file)


def main():
    """
    Run index mapping over a directory of input
    """
    input_file_list = os.listdir(INPUT_DIR)
    input_file_list = [os.path.join(INPUT_DIR, file) for file in input_file_list]

    #filter for pdb extension
    input_file_list = [file for file in input_file_list if file.endswith(".pdb")]

    for file in input_file_list:
        ref_pdb = PDBFile.read(REF_PDB).get_structure()[0]
        test_pdb = PDBFile.read(file).get_structure()[0]
        transformed = superimpose_structure(ref_pdb, test_pdb)
        
        #structure name of RFDiffusion output
        test_struct_name = os.path.basename(file).split(".")[0]

        #fullpath outfile jsonl
        out_file = os.path.join(OUT_DIR, f"{test_struct_name}_fixed.jsonl")

        #get residue mapping
        residue_map = residue_numeric_mapping(ref_pdb, transformed, TEMPLATE_RESIDUE_LIST)
        write_jsonl_string(residue_map, test_struct_name, "A", out_file)

if __name__ == "__main__":
    main()

    



